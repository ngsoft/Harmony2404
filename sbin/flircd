#!/bin/bash
# Detects if flirc device is connected and 
# launch LIRC, and write to pipe

[[ $(pgrep -c flircd) -gt 1 ]] && exit 0

function throw(){
    echo $@ >&2
    exit 1
}

if [ "$(id -u)" != "0" ]; then throw "This script can only be run by root user"; fi
if [ -z "$HARMONY_APPLICATION_PREFIX" ]; then 
    cwd="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
    base=$(basename ${BASH_SOURCE[0]})
    if [ -z "$cwd" ] || [ ! -x "$cwd/$base" ]; then throw $error; fi
    HARMONY_APPLICATION_PREFIX="$(dirname "$cwd")"
    unset -v base cwd
else HARMONY_FLIRCD_SYSTEMD=1; fi


[ -e "$HARMONY_APPLICATION_PREFIX/lib/harmony/env.sh" ] || throw "Cannot load Environment"

source "$HARMONY_APPLICATION_PREFIX/lib/harmony/env.sh"
source bash-utils.sh


if [ ! -d "$HARMONY_FLIRC_PATH" ]; then mkdir -m 775 -p $HARMONY_FLIRC_PATH; fi

function.copy log oldlog

# < https://blog.selectel.com/managing-logging-systemd/ >
# loglevels
#   0 — Emergency: system is unusable
#   1 — Alert: action must be taken immediately
#   2 — Critical: critical conditions
#   3 — Error: error conditions
#   4 — Warning: warning conditions
#   5 — Notice: normal but significant condition
#   6 — Informational: informational messages
#   7 — Debug: debug-level messages

function log(){
    local message="$@"
    if [[ $HARMONY_FLIRCD_SYSTEMD == 1 ]]; then  echo "<7> $message"; fi
    oldlog $message
}

logfile=$HARMONY_FIRCD_LOGFILE

#Inputlirc
new Process InputLIRC inputlircd
#IREXEC
new Process IREXEC irexec

# adding method to InputLIRC instance
function InputLIRC.start(){
    InputLIRC.running && return 1
    log "Starting InputLIRC."
    > /dev/null 2>&1 $HARMONY_APPLICATION_PREFIX/sbin/inputlircd -r 300 -m 0 -t $HARMONY_FLIRC_KEYMAPS -n *flirc* -x FLIRC -d /var/run/lirc/lircd -g -c &
    if InputLIRC.wait.running; then
        chown -R root:sudo /var/run/lirc
        cmd chmod -R 775 /var/run/lirc
        if InputLIRC.running; then
            log "InputLIRC Start Success"
            return 0
        else log "InputLIRC start failure"; return 1; fi
    fi
}

# adding method to IREXEC instance
function IREXEC.start(){
    IREXEC.running && return 1
    InputLIRC.running || return 1
    log Starting IREXEC
    if [ ! -p "$HARMONY_FLIRC_FIFO" ]; then 
        mkfifo "$HARMONY_FLIRC_FIFO"
        chown -R root:sudo $HARMONY_FLIRC_PATH
        cmd chmod -R 775 $HARMONY_FLIRC_PATH
    fi
    # autogenerate config based on keymaps (if they are changed)
    if [ ! -e "$HARMONY_FLIRCD_IREXEC" ]; then
        parse.configfile $HARMONY_FLIRC_KEYMAPS irexeckeys
        for key in "${irexeckeys[@]}"; do
cat >> $HARMONY_FLIRCD_IREXEC <<EOF
begin
    prog    =  harmony
    remote  =  FLIRC
    button  =  $key
    repeat  =  0
    delay   =  0
    config  =  echo $key > $HARMONY_FLIRC_FIFO &
end
EOF
        done
    fi
    irexec -n harmony -d $HARMONY_FLIRCD_IREXEC &
    if IREXEC.wait.running; then
        if IREXEC.running; then
            log "IREXEC Start Success"
            return 0
        else log "IREXEC start failure"; return 1;fi
    fi
}


function cleanup(){
    cmd killall irexec
    cmd killall lircd
    cmd killall inputlircd
    cmd rm -f $HARMONY_FLIRCD_PIDFILE
    cmd rm -f $HARMONY_FLIRCD_IREXEC
    cmd rm -f $HARMONY_FLIRC_FIFO
}


do.kill(){
    exit 0
}

do.exit(){
    cleanup
    log "Stopping FLIRC Daemon"
    return 0
}


trap do.exit EXIT
trap do.kill SIGINT SIGTERM SIGQUIT



require flirc
flirc_load_config=0
canloop=1
lastsignal=0
loop=0
interval=.2
timeout=25
canstart=1
logged=0

cleanup

echo $BASHPID > $HARMONY_FLIRCD_PIDFILE
HARMONY_FLIRCD_PID=$BASHPID

log "Starting FLIRC Daemon."

while [[ $canloop == 1 ]]; do
    if [[ $loop == $timeout ]] || [[ $canstart == 1 ]]; then
        if ! flirc.connected; then
            if [ "$(flirc.status)" == "bootloader" ]; then 
                log "Flirc on bootloader, fixing dfu."
                flirc.fixdfu
                flirc_load_config=1
            fi
        fi
        if flirc.connected; then
            if [[ $flirc_load_config == 1 ]]; then
                log "Loading FLIRC Config"
                source $HARMONY_FLIRC_CONFIG
                flirc_load_config=0
            fi
            ! InputLIRC.running && InputLIRC.start        
            if InputLIRC.running; then
                if ! IREXEC.running; then IREXEC.start; fi
            fi
            logged=0
        else
            [[ $logged == 0 ]] && log "Device is disconnected";
            if IREXEC.running; then 
                log "Device is disconnected, stopping IREXEC"
                IREXEC.kill; 
            fi
            if InputLIRC.running; then 
                log "Device is disconnected, stopping InputLIRC"
                InputLIRC.kill; 
            fi
            logged=1
        fi
        canstart=0
        loop=0
        continue
    fi
    sleep $interval
    ((loop+=1))
done